--- memtest86+-2.11/test.c.orig	2008-11-15 19:18:14.000000000 -0500
+++ memtest86+-2.11/test.c	2009-08-17 17:21:42.904932613 -0400
@@ -13,6 +13,7 @@
 #include "config.h"
 #include <sys/io.h>
 #include "dmi.h"
+#include <inttypes.h>
 
 extern int segs, bail;
 extern volatile ulong *p;
@@ -150,7 +151,7 @@ void addr_tst2()
 		done = 0;
 		do {
 			/* Check for overflow */
-			if (pe + SPINSZ > pe) {
+			if ((uintptr_t)(pe + SPINSZ) > (uintptr_t)pe) {
 				pe += SPINSZ;
 			} else {
 				pe = end;
@@ -194,7 +195,7 @@ void addr_tst2()
 		done = 0;
 		do {
 			/* Check for overflow */
-			if (pe + SPINSZ > pe) {
+			if ((uintptr_t)(pe + SPINSZ) > (uintptr_t)pe) {
 				pe += SPINSZ;
 			} else {
 				pe = end;
@@ -256,17 +257,19 @@ void addr_tst2()
  */
 void movinvr()
 {
-	int i, j, done, seed1, seed2;
+	int i, seed1, seed2;
+	int j, done;
 	volatile ulong *pe;
 	volatile ulong *start,*end;
 	ulong num;
+	uintptr_t next;
 
 	/* Initialize memory with initial sequence of random numbers.  */
 	if (v->rdtsc) {
 		asm __volatile__ ("rdtsc":"=a" (seed1),"=d" (seed2));
 	} else {
-		seed1 = 521288629 + v->pass;
-		seed2 = 362436069 - v->pass;
+		seed1 = (int)(521288629 + v->pass);
+		seed2 = (int)(362436069 - v->pass);
 	}
 
 	/* Display the current seed */
@@ -277,28 +280,20 @@ void movinvr()
 		end = v->map[j].end;
 		pe = start;
 		p = start;
+		next = (uintptr_t)p;
 		done = 0;
 		do {
 			/* Check for overflow */
-			if (pe + SPINSZ > pe) {
+			if (((uintptr_t)(pe + SPINSZ) > (uintptr_t)pe) &&
+			    ((uintptr_t)(pe + SPINSZ) < (uintptr_t)end)) {
 				pe += SPINSZ;
 			} else {
 				pe = end;
-			}
-			if (pe >= end) {
-				pe = end;
 				done++;
 			}
-			if (p == pe ) {
+			if (next == (uintptr_t)pe) {
 				break;
 			}
-/* Original C code replaced with hand tuned assembly code */
-/*
-			for (; p < pe; p++) {
-				*p = rand();
-			}
- */
-
 			asm __volatile__ (
 				"jmp L200\n\t"
 				".p2align 4,,7\n\t"
@@ -310,7 +305,7 @@ void movinvr()
 				"jb L200\n\t"
 				: "=D" (p)
 				: "D" (p), "b" (pe)
-				: "eax"
+				: "eax", "edx"
 			);
 
 			do_tick();
@@ -324,23 +319,28 @@ void movinvr()
 	for (i=0; i<2; i++) {
 		rand_seed(seed1, seed2);
 		for (j=0; j<segs; j++) {
-			start = v->map[j].start;
-			end = v->map[j].end;
+			start = (ulong *)(v->map[j].start);
+			end = (ulong *)(v->map[j].end);
 			pe = start;
 			p = start;
 			done = 0;
 			do {
 				/* Check for overflow */
-				if (pe + SPINSZ > pe) {
+				next = (uintptr_t)(pe + SPINSZ);
+				if ((next > (uintptr_t)pe) &&
+				    (next < (uintptr_t)end)) {
 					pe += SPINSZ;
 				} else {
 					pe = end;
+					done++;
 				}
+#if 0
 				if (pe >= end) {
 					pe = end;
 					done++;
 				}
-				if (p == pe ) {
+#endif
+				if ((uintptr_t)p == (uintptr_t)pe) {
 					break;
 				}
 /* Original C code replaced with hand tuned assembly code */
@@ -359,8 +359,9 @@ void movinvr()
 				if (i) {
 					num = 0xffffffff;
 				} else {
-					num = 0;
+					num = 0x0;
 				}
+	
 				asm __volatile__ (
 					"jmp L26\n\t" \
 
@@ -427,7 +428,7 @@ void movinv1(int iter, ulong p1, ulong p
 		done = 0;
 		do {
 			/* Check for overflow */
-			if (pe + SPINSZ > pe) {
+			if ((uintptr_t)(pe + SPINSZ) > (uintptr_t)pe) {
 				pe += SPINSZ;
 			} else {
 				pe = end;
@@ -468,7 +469,7 @@ void movinv1(int iter, ulong p1, ulong p
 			done = 0;
 			do {
 				/* Check for overflow */
-				if (pe + SPINSZ > pe) {
+				if ((uintptr_t)(pe + SPINSZ) > (uintptr_t)pe) {
 					pe += SPINSZ;
 				} else {
 					pe = end;
@@ -534,7 +535,7 @@ void movinv1(int iter, ulong p1, ulong p
 			done = 0;
 			do {
 				/* Check for underflow */
-				if (pe - SPINSZ < pe) {
+				if ((uintptr_t)(pe - SPINSZ) < (uintptr_t)pe) {
 					pe -= SPINSZ;
 				} else {
 					pe = start;
@@ -623,7 +624,7 @@ void movinv32(int iter, ulong p1, ulong 
 		pat = p1;
 		do {
 			/* Check for overflow */
-			if (pe + SPINSZ > pe) {
+			if ((uintptr_t)(pe + SPINSZ) > (uintptr_t)pe) {
 				pe += SPINSZ;
 			} else {
 				pe = end;
@@ -685,7 +686,7 @@ void movinv32(int iter, ulong p1, ulong 
 			pat = p1;
 			do {
 				/* Check for overflow */
-				if (pe + SPINSZ > pe) {
+				if ((uintptr_t)(pe + SPINSZ) > (uintptr_t)pe) {
 					pe += SPINSZ;
 				} else {
 					pe = end;
@@ -798,7 +799,7 @@ void movinv32(int iter, ulong p1, ulong 
 			done = 0;
 			do {
 				/* Check for underflow */
-				if (pe - SPINSZ < pe) {
+				if ((uintptr_t)(pe - SPINSZ) < (uintptr_t)pe) {
 					pe -= SPINSZ;
 				} else {
 					pe = start;
@@ -906,7 +907,7 @@ void modtst(int offset, int iter, ulong 
 		done = 0;
 		do {
 			/* Check for overflow */
-			if (pe + SPINSZ > pe) {
+			if ((uintptr_t)(pe + SPINSZ) > (uintptr_t)pe) {
 				pe += SPINSZ;
 			} else {
 				pe = end;
@@ -951,7 +952,7 @@ void modtst(int offset, int iter, ulong 
 			k = 0;
 			do {
 				/* Check for overflow */
-				if (pe + SPINSZ > pe) {
+				if ((uintptr_t)(pe + SPINSZ) > (uintptr_t)pe) {
 					pe += SPINSZ;
 				} else {
 					pe = end;
@@ -1009,7 +1010,7 @@ void modtst(int offset, int iter, ulong 
 		done = 0;
 		do {
 			/* Check for overflow */
-			if (pe + SPINSZ > pe) {
+			if ((uintptr_t)(pe + SPINSZ) > (uintptr_t)pe) {
 				pe += SPINSZ;
 			} else {
 				pe = end;
@@ -1098,8 +1099,9 @@ void block_move(int iter)
 		done = 0;
 		do {
 			/* Check for overflow */
-			if (pe + SPINSZ*4 > pe) {
-				pe += SPINSZ*4;
+			if ((uintptr_t)(pe + SPINSZ * sizeof(ulong)) >
+			    (uintptr_t)pe) {
+				pe += SPINSZ * sizeof(ulong);
 			} else {
 				pe = end;
 			}
@@ -1167,8 +1169,9 @@ void block_move(int iter)
 		done = 0;
 		do {
 			/* Check for overflow */
-			if (pe + SPINSZ*4 > pe) {
-				pe += SPINSZ*4;
+			if ((uintptr_t)(pe + SPINSZ * sizeof(ulong)) >
+			    (uintptr_t)pe) {
+				pe += SPINSZ * sizeof(ulong);
 			} else {
 				pe = end;
 			}
@@ -1234,8 +1237,9 @@ void block_move(int iter)
 		done = 0;
 		do {
 			/* Check for overflow */
-			if (pe + SPINSZ*4 > pe) {
-				pe += SPINSZ*4;
+			if ((uintptr_t)(pe + SPINSZ * sizeof(ulong)) >
+			    (uintptr_t)pe) {
+				pe += SPINSZ * sizeof(ulong);
 			} else {
 				pe = end;
 			}
